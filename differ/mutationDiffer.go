// Copyright (c) 2018 Couchbase, Inc.
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific language governing permissions
// and limitations under the License.

package differ

import (
	"encoding/json"
	"fmt"
	gocbcore "github.com/couchbase/gocbcore/v9"
	xdcrBase "github.com/couchbase/goxdcr/base"
	xdcrLog "github.com/couchbase/goxdcr/log"
	"github.com/couchbase/goxdcr/metadata"
	xdcrUtils "github.com/couchbase/goxdcr/utils"
	"io/ioutil"
	"math"
	"os"
	"reflect"
	"strings"
	"sync"
	"sync/atomic"
	"time"
	"xdcrDiffer/base"
	"xdcrDiffer/utils"
)

type MutationDiffer struct {
	sourceBucketName      string
	sourceReference       *metadata.RemoteClusterReference
	targetBucketName      string
	targetReference       *metadata.RemoteClusterReference
	inputDiffKeysFileName string
	srcDiffKeysFileName   string
	tgtDiffKeysFileName   string
	mutationDifferFileDir string
	numberOfWorkers       int
	batchSize             int
	timeout               int

	sourceBucket *GocbcoreAgent
	targetBucket *GocbcoreAgent

	missingFromSource map[uint32]map[string]*gocbcore.GetResult
	missingFromTarget map[uint32]map[string]*gocbcore.GetResult
	srcDiff           map[uint32]map[string][]*gocbcore.GetResult
	tgtDiff           map[uint32]map[string][]*gocbcore.GetResult

	metaMissingFromSource map[uint32]map[string]*gocbcore.GetMetaResult
	metaMissingFromTarget map[uint32]map[string]*gocbcore.GetMetaResult
	metaSrcDiff           map[uint32]map[string][]*gocbcore.GetMetaResult
	metaTgtDiff           map[uint32]map[string][]*gocbcore.GetMetaResult
	deletedFromSource     map[uint32]map[string][]*gocbcore.GetMetaResult
	deletedFromTarget     map[uint32]map[string][]*gocbcore.GetMetaResult
	keysWithError         []*MutationDifferFetchEntry
	stateLock             *sync.RWMutex

	numKeysProcessed  uint32
	numKeysWithErrors uint32
	finChan           chan bool

	maxNumOfSendBatchRetry int
	sendBatchRetryInterval time.Duration
	sendBatchMaxBackoff    time.Duration
	compareBody            bool

	logger *xdcrLog.CommonLogger

	sourceDcpAgent *gocbcore.DCPAgent
	targetDcpAgent *gocbcore.DCPAgent

	colIdsMap           map[uint32][]uint32
	reverseTgtColIdsMap map[uint32][]uint32

	srcCapability metadata.Capability
	tgtCapability metadata.Capability

	migrationHintMap MigrationHintMap

	srcKvSSLPortMap xdcrBase.SSLPortMap
	tgtKvSSLPortMap xdcrBase.SSLPortMap
	srcKvVbMap      map[string][]uint16
	tgtKvVbMap      map[string][]uint16
	utils           xdcrUtils.UtilsIface
}

func NewMutationDiffer(sourceBucketName string, sourceRef *metadata.RemoteClusterReference, targetBucketName string, targetRef *metadata.RemoteClusterReference, fileDifferDir string, mutationDifferFileDir string, numberOfWorkers int, batchSize int, timeout int, maxNumOfSendBatchRetry int, sendBatchRetryInterval time.Duration, sendBatchMaxBackoff time.Duration,
	compareBody bool, logger *xdcrLog.CommonLogger, colIdsMap map[uint32][]uint32, srcCapability metadata.Capability, tgtCapability metadata.Capability, xdcrUtils xdcrUtils.UtilsIface) *MutationDiffer {
	// this indicates that mutation differ is expected to read srcDiff fetchList generated by file differ,
	inputDiffKeysFileName := fileDifferDir + base.FileDirDelimiter + base.DiffKeysFileName
	if len(colIdsMap) == 0 {
		// legacy mode
		colIdsMap = make(map[uint32][]uint32)
		colIdsMap[0] = []uint32{0}
	}
	return &MutationDiffer{
		sourceBucketName:      sourceBucketName,
		sourceReference:       sourceRef,
		targetBucketName:      targetBucketName,
		targetReference:       targetRef,
		inputDiffKeysFileName: inputDiffKeysFileName,
		mutationDifferFileDir: mutationDifferFileDir,
		numberOfWorkers:       numberOfWorkers,
		batchSize:             batchSize,
		timeout:               timeout,
		missingFromSource:     make(map[uint32]map[string]*gocbcore.GetResult),
		missingFromTarget:     make(map[uint32]map[string]*gocbcore.GetResult),
		srcDiff:               make(map[uint32]map[string][]*gocbcore.GetResult),
		tgtDiff:               make(map[uint32]map[string][]*gocbcore.GetResult),
		metaMissingFromSource: make(map[uint32]map[string]*gocbcore.GetMetaResult),
		metaMissingFromTarget: make(map[uint32]map[string]*gocbcore.GetMetaResult),
		metaSrcDiff:           make(map[uint32]map[string][]*gocbcore.GetMetaResult),
		metaTgtDiff:           make(map[uint32]map[string][]*gocbcore.GetMetaResult),
		deletedFromSource:     make(map[uint32]map[string][]*gocbcore.GetMetaResult),
		deletedFromTarget:     make(map[uint32]map[string][]*gocbcore.GetMetaResult),

		keysWithError:          MutationDiffFetchList{},
		stateLock:              &sync.RWMutex{},
		finChan:                make(chan bool),
		maxNumOfSendBatchRetry: maxNumOfSendBatchRetry,
		sendBatchRetryInterval: sendBatchRetryInterval,
		sendBatchMaxBackoff:    sendBatchMaxBackoff,
		compareBody:            compareBody,
		logger:                 logger,
		colIdsMap:              colIdsMap,
		reverseTgtColIdsMap:    compileReverseMap(colIdsMap),
		srcDiffKeysFileName:    utils.DiffKeysFileName(true, fileDifferDir, base.DiffKeysFileName),
		tgtDiffKeysFileName:    utils.DiffKeysFileName(false, fileDifferDir, base.DiffKeysFileName),
		srcCapability:          srcCapability,
		tgtCapability:          tgtCapability,
		utils:                  xdcrUtils,
	}
}

func (d *MutationDiffer) Run() error {
	srcDiffKeys, tgtDiffKeys, migrationHintMap, err := d.loadDiffKeys()
	if err != nil {
		return err
	}
	d.migrationHintMap = migrationHintMap

	srcPovFetchList, srcPovFetchIdx := srcDiffKeys.ToFetchEntries(d.colIdsMap, migrationHintMap)
	tgtPovFetchList, tgtPovFetchIdx := tgtDiffKeys.ToFetchEntries(d.reverseTgtColIdsMap, nil)
	combinedFetchList := dedupFetchLists(srcPovFetchList, srcPovFetchIdx, tgtPovFetchList, tgtPovFetchIdx)

	totalCnt := len(combinedFetchList)

	d.logger.Infof("Mutation srcDiff to work on %v srcPovFetchList with diffs.\n", totalCnt)

	err = d.initialize()
	if err != nil {
		d.logger.Errorf("Error initializing: %v\n", err)
		return err
	}

	go d.reportStatus(totalCnt)

	loadDistribution := utils.BalanceLoad(d.numberOfWorkers, totalCnt)
	waitGroup := &sync.WaitGroup{}
	for i := 0; i < d.numberOfWorkers; i++ {
		lowIndex := loadDistribution[i][0]
		highIndex := loadDistribution[i][1]
		if lowIndex == highIndex {
			// skip workers with 0 load
			continue
		}
		diffWorker := NewDifferWorker(d, d.sourceDcpAgent, d.targetDcpAgent, d.sourceBucket, d.targetBucket, combinedFetchList[lowIndex:highIndex], waitGroup, d.colIdsMap, d.reverseTgtColIdsMap, d.migrationHintMap)
		waitGroup.Add(1)
		go diffWorker.run()
	}

	waitGroup.Wait()

	close(d.finChan)

	return d.writeDiff()
}

func dedupFetchLists(srcPovList MutationDiffFetchList, srcIdx MutationDiffFetchListIdx, tgtPovList MutationDiffFetchList, tgtIdx MutationDiffFetchListIdx) MutationDiffFetchList {
	// The goal is to combine and deduplicate into a single source-side view of the fetch list
	var combinedFetchList MutationDiffFetchList
	combinedFetchIdx := make(MutationDiffFetchListIdx)

	// First go through the source side - and make sure that all matching entries are fetched
	for _, srcFetchEntry := range srcPovList {
		combinedEntry := srcFetchEntry.Clone()

		potentialTgtEntries, exists := tgtIdx[combinedEntry.Key]
		if !exists {
			// Make sure this entry at least has non nil src list
			if len(combinedEntry.TgtColIds) == 0 {
				panic("Will be missing target")
			}
		}
		// potentialTgtEntries are based off of the index and so need to ensure that only matching entries are combined
		for _, chkTgtEntry := range potentialTgtEntries {
			var foundMatching bool
			// From target's pov, the TgtColIds are to be source's
			for _, chkSrcId := range chkTgtEntry.TgtColIds {
				if chkSrcId == combinedEntry.SrcColId {
					// This entry matches
					foundMatching = true
					// Make sure that this target's colId exists in the centralized fetch list
					var foundTgt bool
					for _, chkTgtId := range combinedEntry.TgtColIds {
						// chkTgtEntry is from tgt's pov... ensure that tgt's pov, the srcColId is covered
						if chkTgtId == chkTgtEntry.SrcColId {
							foundTgt = true
							break
						}
					}
					if !foundTgt {
						// This target's colId needs to be in the combinedEntry to ensure it is fetched from target KV
						combinedEntry.TgtColIds = append(combinedEntry.TgtColIds, chkTgtEntry.SrcColId)
					}
					break
				}
			}
			if foundMatching {
				break
			}
		}
		combinedFetchList = append(combinedFetchList, combinedEntry)
		combinedFetchIdx.AddEntry(combinedEntry)
	}

	// Now, go through the target side to ensure that if anything the source missed, it is covered
	for _, tgtFetchEntry := range tgtPovList {
		potentialCombinedEntries, exists := combinedFetchIdx[tgtFetchEntry.Key]
		if !exists {
			// This means that this key is not even being fetched from the source at all
			// need to add it to be fetched so that the diff algo can find it
			srcEntries := tgtFetchEntry.Reverse()
			for _, addOneEntry := range srcEntries {
				combinedFetchList = append(combinedFetchList, addOneEntry)
				combinedFetchIdx.AddEntry(addOneEntry)
			}
			continue
		}

		// Key is being fetched from the source but need to check to make sure that the right colId is being fetched
		// since we are working off of the index
		for _, chkSrcColId := range tgtFetchEntry.TgtColIds {
			var foundSourceEntry bool
			for _, potentialEntry := range potentialCombinedEntries {
				if potentialEntry.SrcColId == chkSrcColId {
					foundSourceEntry = true
					break
				}
			}
			if foundSourceEntry {
				break
			} else {
				// From target's pov, the sourceColId -> tgtMap entry is missing
				// This means that for a key that exists in the source's collection, it isn't aware that
				// this target collection also needs to be fetched
				// Add them into the combinedFetchList
				srcEntries := tgtFetchEntry.Reverse()
				for _, addOneEntry := range srcEntries {
					combinedFetchList = append(combinedFetchList, addOneEntry)
					combinedFetchIdx.AddEntry(addOneEntry)
				}
			}
		}
	}
	return combinedFetchList
}

func (d *MutationDiffer) reportStatus(totalKeys int) {
	ticker := time.NewTicker(time.Duration(base.StatsReportInterval) * time.Second)
	defer ticker.Stop()

	var prevNumKeysProcessed uint32 = math.MaxUint32

	for {
		select {
		case <-ticker.C:
			numKeysProcessed := atomic.LoadUint32(&d.numKeysProcessed)
			numKeysWithErrors := atomic.LoadUint32(&d.numKeysWithErrors)
			if prevNumKeysProcessed != math.MaxUint32 {
				d.logger.Infof("%v Mutation differ processed %v fetchList out of %v fetchList. processing rate=%v key/sec\n", time.Now(), numKeysProcessed, totalKeys, (numKeysProcessed-prevNumKeysProcessed)/base.StatsReportInterval)
			} else {
				d.logger.Infof("%v Mutation differ processed %v fetchList out of %v fetchList.\n", time.Now(), numKeysProcessed, totalKeys)

			}
			if numKeysWithErrors > 0 {
				d.logger.Warnf("%v skipped %v fetchList because of errors\n", time.Now(), numKeysWithErrors)
			}
			if numKeysProcessed == uint32(totalKeys) {
				return
			}
			prevNumKeysProcessed = numKeysProcessed
		case <-d.finChan:
			return
		}
	}
}

func (d *MutationDiffer) writeDiff() error {
	err := d.writeKeysWithError()
	if err != nil {
		d.logger.Errorf("Error writing fetchList with errors. err=%v\n", err)
	}

	err = d.writeCollectionMapping()
	if err != nil {
		d.logger.Errorf("Error collection mapping with errors. err=%v\n", err)
	}

	err = d.writeDiffDetails()
	if err != nil {
		d.logger.Errorf("Error writing srcDiff details. err=%v\n", err)
	}
	return err
}

func (d *MutationDiffer) writeDiffDetails() error {
	diffBytes, err := d.getDiffBytes()
	if err != nil {
		return err
	}
	return d.writeDiffBytesToFile(diffBytes)
}

func (d *MutationDiffer) writeCollectionMapping() error {
	fileName := base.MutationDiffColIdMapping
	srcMapFilename := d.mutationDifferFileDir + base.FileDirDelimiter + fileName

	srcMappingBytes, srcErr := json.Marshal(d.colIdsMap)
	if srcErr != nil {
		d.logger.Errorf("Unable to marshal colIdsMap: %v\n", d.colIdsMap)
	} else {
		srcErr = ioutil.WriteFile(srcMapFilename, srcMappingBytes, 0644)
	}

	if srcErr != nil {
		return srcErr
	} else {
		return nil
	}
}

func (d *MutationDiffer) writeKeysWithError() error {
	keysWithErrorBytes, err := json.Marshal(d.keysWithError)
	if err != nil {
		return err
	}

	keysWithErrorFileName := d.mutationDifferFileDir + base.FileDirDelimiter + base.DiffErrorKeysFileName
	keysWithErrorFile, err := os.OpenFile(keysWithErrorFileName, os.O_RDWR|os.O_CREATE, base.FileModeReadWrite)
	if err != nil {
		return err
	}

	defer keysWithErrorFile.Close()

	_, err = keysWithErrorFile.Write(keysWithErrorBytes)
	return err
}

func (d *MutationDiffer) getDiffBytes() ([]byte, error) {
	if d.compareBody == false {
		outputMap := map[string]interface{}{
			"Mismatch":          d.metaSrcDiff,
			"MissingFromSource": d.metaMissingFromSource,
			"MissingFromTarget": d.metaMissingFromTarget,
			"DeletedFromSource": d.deletedFromSource,
			"DeletedFromTarget": d.deletedFromTarget,
		}
		return json.Marshal(outputMap)
	}
	outputMap := map[string]interface{}{
		"Mismatch":          d.srcDiff,
		"MissingFromSource": d.missingFromSource,
		"MissingFromTarget": d.missingFromTarget,
	}
	return json.Marshal(outputMap)
}

func (d *MutationDiffer) writeDiffBytesToFile(diffBytes []byte) error {
	fileName := base.MutationDiffFileName
	fullFileName := d.mutationDifferFileDir + base.FileDirDelimiter + fileName

	diffFile, err := os.OpenFile(fullFileName, os.O_RDWR|os.O_CREATE, base.FileModeReadWrite)
	if err != nil {
		return err
	}

	defer diffFile.Close()

	_, err = diffFile.Write(diffBytes)
	return err

}

func (d *MutationDiffer) loadDiffKeys() (DiffKeysMap, DiffKeysMap, MigrationHintMap, error) {
	srcDiffKeysBytes, err := ioutil.ReadFile(d.srcDiffKeysFileName)
	if err != nil {
		return nil, nil, nil, err
	}

	tgtDiffKeyBytes, err := ioutil.ReadFile(d.tgtDiffKeysFileName)
	if err != nil {
		return nil, nil, nil, err
	}

	// migration hint map may or may not exist
	var migrationHintFound bool
	migrationHintFile := fmt.Sprintf("%v_%v", d.srcDiffKeysFileName, base.DiffKeysSrcMigrationHintSuffix)
	migrationHintBytes, err := ioutil.ReadFile(migrationHintFile)
	if err == nil {
		migrationHintFound = true
	}

	srcDiffKeys := make(DiffKeysMap)
	tgtDiffKeys := make(DiffKeysMap)
	migrationHintMap := make(MigrationHintMap)

	err = json.Unmarshal(srcDiffKeysBytes, &srcDiffKeys)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("srcUnmarshal %v", err)
	}
	err = json.Unmarshal(tgtDiffKeyBytes, &tgtDiffKeys)
	if err != nil {
		return nil, nil, nil, fmt.Errorf("tgtUnmarshal %v", err)
	}

	if migrationHintFound {
		err = json.Unmarshal(migrationHintBytes, &migrationHintMap)
		if err != nil {
			return nil, nil, nil, fmt.Errorf("hintUnmarshal %v", err)
		}
	}

	return srcDiffKeys, tgtDiffKeys, migrationHintMap, nil
}

func (d *MutationDiffer) addDocDiff(missingFromSource, missingFromTarget map[uint32]map[string]*gocbcore.GetResult,
	srcDiff, tgtDiff map[uint32]map[string][]*gocbcore.GetResult,
	srcBodyDiff, tgtBodyDiff map[uint32]map[string][]*gocbcore.GetResult) {
	d.stateLock.Lock()
	defer d.stateLock.Unlock()

	for colId, missingFromSourcePerCol := range missingFromSource {
		if _, exists := d.missingFromSource[colId]; !exists {
			d.missingFromSource[colId] = make(map[string]*gocbcore.GetResult)
		}
		for key, result := range missingFromSourcePerCol {
			d.missingFromSource[colId][key] = result
		}
	}

	for colId, missingFromTargetPerCol := range missingFromTarget {
		if _, exists := d.missingFromTarget[colId]; !exists {
			d.missingFromTarget[colId] = make(map[string]*gocbcore.GetResult)
		}
		for key, result := range missingFromTargetPerCol {
			d.missingFromTarget[colId][key] = result
		}
	}

	for colId, srcDiffPerCol := range srcDiff {
		if _, exists := d.srcDiff[colId]; !exists {
			d.srcDiff[colId] = make(map[string][]*gocbcore.GetResult)
		}
		for key, results := range srcDiffPerCol {
			d.srcDiff[colId][key] = results
		}
	}

	for colId, tgtDiffPerCol := range tgtDiff {
		if _, exists := d.tgtDiff[colId]; !exists {
			d.tgtDiff[colId] = make(map[string][]*gocbcore.GetResult)
		}
		for key, results := range tgtDiffPerCol {
			d.tgtDiff[colId][key] = results
		}
	}
}

func (d *MutationDiffer) addMetaDiff(missingFromSource, missingFromTarget map[uint32]map[string]*gocbcore.GetMetaResult,
	deletedFromSource, deletedFromTarget map[uint32]map[string][]*gocbcore.GetMetaResult, srcDiff, tgtDiff map[uint32]map[string][]*gocbcore.GetMetaResult) {
	d.stateLock.Lock()
	defer d.stateLock.Unlock()

	for colId, missingFromSourcePerCol := range missingFromSource {
		if _, exists := d.metaMissingFromSource[colId]; !exists {
			d.metaMissingFromSource[colId] = make(map[string]*gocbcore.GetMetaResult)
		}
		for key, result := range missingFromSourcePerCol {
			d.metaMissingFromSource[colId][key] = result
		}
	}

	for colId, missingFromTargetPerCol := range missingFromTarget {
		if _, exists := d.metaMissingFromTarget[colId]; !exists {
			d.metaMissingFromTarget[colId] = make(map[string]*gocbcore.GetMetaResult)
		}
		for key, result := range missingFromTargetPerCol {
			d.metaMissingFromTarget[colId][key] = result
		}
	}

	for colId, deleteFromSourcePerCol := range deletedFromSource {
		if _, exists := d.deletedFromSource[colId]; !exists {
			d.deletedFromSource[colId] = make(map[string][]*gocbcore.GetMetaResult)
		}
		for key, results := range deleteFromSourcePerCol {
			d.deletedFromSource[colId][key] = results
		}
	}

	for colId, deleteFromTargetPerCol := range deletedFromTarget {
		if _, exists := d.deletedFromTarget[colId]; !exists {
			d.deletedFromTarget[colId] = make(map[string][]*gocbcore.GetMetaResult)
		}
		for key, results := range deleteFromTargetPerCol {
			d.deletedFromTarget[colId][key] = results
		}
	}

	for colId, srcDiffPerCol := range srcDiff {
		if _, exists := d.metaSrcDiff[colId]; !exists {
			d.metaSrcDiff[colId] = make(map[string][]*gocbcore.GetMetaResult)
		}
		for key, results := range srcDiffPerCol {
			d.metaSrcDiff[colId][key] = results
		}
	}

	for colId, tgtDiffPerCol := range tgtDiff {
		if _, exists := d.metaTgtDiff[colId]; !exists {
			d.metaTgtDiff[colId] = make(map[string][]*gocbcore.GetMetaResult)
		}
		for key, results := range tgtDiffPerCol {
			d.metaTgtDiff[colId][key] = results
		}
	}
}

func (d *MutationDiffer) addKeysWithError(keysWithError MutationDiffFetchList) {
	d.stateLock.Lock()
	defer d.stateLock.Unlock()
	d.keysWithError = append(d.keysWithError, keysWithError...)
	atomic.AddUint32(&d.numKeysWithErrors, uint32(len(keysWithError)))
}

type DifferWorker struct {
	differ           *MutationDiffer
	fetchList        MutationDiffFetchList
	sourceBucket     *GocbcoreAgent
	targetBucket     *GocbcoreAgent
	sourceDcpAgent   *gocbcore.DCPAgent
	targetDcpAgent   *gocbcore.DCPAgent
	waitGroup        *sync.WaitGroup
	sourceResults    map[uint32]map[string]Result
	targetResults    map[uint32]map[string]Result
	resultsLock      sync.RWMutex
	logger           *xdcrLog.CommonLogger
	colIds           map[uint32][]uint32
	reverseColIds    map[uint32][]uint32
	migrationHintMap MigrationHintMap
}

func NewDifferWorker(differ *MutationDiffer, sourceDCPAgent, targetDCPAgent *gocbcore.DCPAgent, sourceBucket, targetBucket *GocbcoreAgent, fetchList MutationDiffFetchList, waitGroup *sync.WaitGroup, colIds, reverseColIds map[uint32][]uint32, migrationHintMap MigrationHintMap) *DifferWorker {
	return &DifferWorker{
		differ:           differ,
		sourceBucket:     sourceBucket,
		targetBucket:     targetBucket,
		fetchList:        fetchList,
		waitGroup:        waitGroup,
		sourceResults:    make(map[uint32]map[string]Result),
		targetResults:    make(map[uint32]map[string]Result),
		logger:           differ.logger,
		sourceDcpAgent:   sourceDCPAgent,
		targetDcpAgent:   targetDCPAgent,
		colIds:           colIds,
		reverseColIds:    reverseColIds,
		migrationHintMap: migrationHintMap,
	}
}

func compileReverseMap(srcToTgts map[uint32][]uint32) map[uint32][]uint32 {
	reverseMap := make(map[uint32][]uint32)

	for srcColId, tgtColIds := range srcToTgts {
		for _, tgtColId := range tgtColIds {
			if _, exists := reverseMap[tgtColId]; !exists {
				reverseMap[tgtColId] = []uint32{}
			}
			var srcExists bool
			for _, chkColId := range reverseMap[tgtColId] {
				if chkColId == srcColId {
					srcExists = true
					break
				}
			}
			if !srcExists {
				reverseMap[tgtColId] = append(reverseMap[tgtColId], srcColId)
			}
		}
	}
	return reverseMap
}

func (dw *DifferWorker) run() {
	defer dw.waitGroup.Done()
	dw.getResults()
	dw.diff()
}

func (dw *DifferWorker) getResults() {
	index := 0
	for {
		if index >= len(dw.fetchList) {
			break
		}

		if index+dw.differ.batchSize < len(dw.fetchList) {
			dw.sendBatchWithRetry(index, index+dw.differ.batchSize)
			index += dw.differ.batchSize
			continue
		}

		dw.sendBatchWithRetry(index, len(dw.fetchList))
		break
	}

}

func (dw *DifferWorker) sendBatchWithRetry(startIndex, endIndex int) {
	sendBatchFunc := func() error {
		batch := NewBatch(dw, startIndex, endIndex)
		err := batch.send()
		if err != nil {
			return err
		}
		dw.mergeResults(batch)
		return nil
	}

	opErr := utils.ExponentialBackoffExecutor("sendBatchWithRetry", dw.differ.sendBatchRetryInterval, dw.differ.maxNumOfSendBatchRetry,
		base.SendBatchBackoffFactor, dw.differ.sendBatchMaxBackoff, sendBatchFunc)
	if opErr != nil {
		dw.logger.Warnf("Skipped check on %v fetchList because of err=%v.\n", endIndex-startIndex, opErr)
		dw.differ.addKeysWithError(dw.fetchList[startIndex:endIndex])
	}
	// fetchList with error are also counted toward keysProcessed
	atomic.AddUint32(&dw.differ.numKeysProcessed, uint32(endIndex-startIndex))
}

// merge results obtained by batch into dw
// no need to lock results in dw since it is never accessed concurrently
// need to lock results in batch since it could still be updated when mergeResults is called
func (dw *DifferWorker) mergeResults(b *batch) {
	for colId, results := range b.sourceResults {
		if _, exists := dw.sourceResults[colId]; !exists {
			dw.sourceResults[colId] = make(map[string]Result)
		}
		for key, result := range results {
			dw.sourceResults[colId][key] = result.Clone()
		}
	}
	for colId, results := range b.targetResults {
		if _, exists := dw.targetResults[colId]; !exists {
			dw.targetResults[colId] = make(map[string]Result)
		}
		for key, result := range results {
			dw.targetResults[colId][key] = result.Clone()
		}
	}
}

func (dw *DifferWorker) diff() {
	if dw.differ.compareBody {
		dw.diffGetResult()
	} else {
		dw.diffGetMetaResult()
	}
}

func (dw *DifferWorker) diffGetResult() {
	missingFromSource := make(map[uint32]map[string]*gocbcore.GetResult)
	missingFromTarget := make(map[uint32]map[string]*gocbcore.GetResult)
	srcDiff := make(map[uint32]map[string][]*gocbcore.GetResult)
	tgtDiff := make(map[uint32]map[string][]*gocbcore.GetResult)
	srcBodyDiff := make(map[uint32]map[string][]*gocbcore.GetResult)
	tgtBodyDiff := make(map[uint32]map[string][]*gocbcore.GetResult)

	migrationMode := len(dw.migrationHintMap) > 0

	for srcColId, sourceResultMap := range dw.sourceResults {
		for key, sourceResult := range sourceResultMap {
			if sourceResult.Key() == "" {
				continue
			}

			var tgtColIds []uint32
			if migrationMode {
				tgtColIds = dw.migrationHintMap[key]
			} else {
				tgtColIds = dw.colIds[srcColId]
			}

			for _, tgtColId := range tgtColIds {
				targetResult := dw.targetResults[tgtColId][key]
				if targetResult.Key() == "" {
					continue
				}
				if isKeyNotFoundError(sourceResult.Error()) && !isKeyNotFoundError(targetResult.Error()) {
					if _, exists := missingFromSource[srcColId]; !exists {
						missingFromSource[srcColId] = make(map[string]*gocbcore.GetResult)
					}
					missingFromSource[srcColId][key] = targetResult.GoCbResult().(*gocbcore.GetResult)
					continue
				}
				if !isKeyNotFoundError(sourceResult.Error()) && isKeyNotFoundError(targetResult.Error()) {
					if _, exists := missingFromTarget[tgtColId]; !exists {
						missingFromTarget[tgtColId] = make(map[string]*gocbcore.GetResult)
					}
					missingFromTarget[tgtColId][key] = sourceResult.GoCbResult().(*gocbcore.GetResult)
					continue
				}
				if !areGetResultsTheSame(sourceResult.GoCbResult().(*gocbcore.GetResult), targetResult.GoCbResult().(*gocbcore.GetResult)) {
					if _, exists := srcDiff[srcColId]; !exists {
						srcDiff[srcColId] = make(map[string][]*gocbcore.GetResult)
					}
					srcDiff[srcColId][key] = append(srcDiff[srcColId][key], []*gocbcore.GetResult{sourceResult.GoCbResult().(*gocbcore.GetResult), targetResult.GoCbResult().(*gocbcore.GetResult)}...)
					if _, exists := tgtDiff[tgtColId]; !exists {
						tgtDiff[tgtColId] = make(map[string][]*gocbcore.GetResult)
					}
					tgtDiff[tgtColId][key] = append(tgtDiff[tgtColId][key], []*gocbcore.GetResult{targetResult.GoCbResult().(*gocbcore.GetResult), sourceResult.GoCbResult().(*gocbcore.GetResult)}...)
				}
				if !areGetResultsBodyTheSame(sourceResult.GoCbResult().(*gocbcore.GetResult), targetResult.GoCbResult().(*gocbcore.GetResult)) {
					if _, exists := srcBodyDiff[srcColId]; !exists {
						srcBodyDiff[srcColId] = make(map[string][]*gocbcore.GetResult)
					}
					srcBodyDiff[srcColId][key] = append(srcBodyDiff[srcColId][key], []*gocbcore.GetResult{sourceResult.GoCbResult().(*gocbcore.GetResult), targetResult.GoCbResult().(*gocbcore.GetResult)}...)
					if _, exists := tgtBodyDiff[tgtColId]; !exists {
						tgtBodyDiff[tgtColId] = make(map[string][]*gocbcore.GetResult)
					}
					tgtBodyDiff[tgtColId][key] = append(tgtBodyDiff[tgtColId][key], []*gocbcore.GetResult{targetResult.GoCbResult().(*gocbcore.GetResult), sourceResult.GoCbResult().(*gocbcore.GetResult)}...)
				}
			}
		}
	}

	// Need to do a double-take from target's point of view - check to see if certain things are missing from source
	for tgtColId, targetResultMap := range dw.targetResults {
		for key, targetResult := range targetResultMap {
			if targetResult.Key() == "" {
				continue
			}

			srcColIds := dw.reverseColIds[tgtColId]
			var foundSourceColId bool
			var keyExists bool
			for _, srcColId := range srcColIds {
				_, exists := dw.sourceResults[srcColId]
				if exists {
					foundSourceColId = true
					_, keyExists = dw.sourceResults[srcColId][key]
					break
				}
			}
			if !foundSourceColId || !keyExists {
				// This means that the source colId doesn't exist for this target entry
				if _, exists := missingFromTarget[tgtColId]; !exists {
					missingFromTarget[tgtColId] = make(map[string]*gocbcore.GetResult)
				}
				missingFromTarget[tgtColId][key] = targetResult.GoCbResult().(*gocbcore.GetResult)
			}
		}
	}

	dw.differ.addDocDiff(missingFromSource, missingFromTarget, srcDiff, tgtDiff, srcBodyDiff, tgtBodyDiff)
}

func (dw *DifferWorker) diffGetMetaResult() {
	missingFromSource := make(map[uint32]map[string]*gocbcore.GetMetaResult)
	missingFromTarget := make(map[uint32]map[string]*gocbcore.GetMetaResult)
	srcDiff := make(map[uint32]map[string][]*gocbcore.GetMetaResult)
	tgtDiff := make(map[uint32]map[string][]*gocbcore.GetMetaResult)
	deletedFromSource := make(map[uint32]map[string][]*gocbcore.GetMetaResult)
	deletedFromTarget := make(map[uint32]map[string][]*gocbcore.GetMetaResult)

	migrationMode := len(dw.migrationHintMap) > 0

	for srcColId, sourceResultMap := range dw.sourceResults {
		for key, sourceResultIfc := range sourceResultMap {
			sourceResult := sourceResultIfc.(*GetMetaResult)
			if sourceResult.Key() == "" {
				continue
			}

			var tgtColIds []uint32
			if migrationMode {
				tgtColIds = dw.migrationHintMap[key]
			} else {
				tgtColIds = dw.colIds[srcColId]
			}

			for _, tgtColId := range tgtColIds {
				targetResult := dw.targetResults[tgtColId][key]
				if targetResult.Key() == "" {
					continue
				}
				if isKeyNotFoundError(sourceResult.Error()) && !isKeyNotFoundError(targetResult.Error()) {
					if _, exists := missingFromSource[srcColId]; !exists {
						missingFromSource[srcColId] = make(map[string]*gocbcore.GetMetaResult)
					}
					missingFromSource[srcColId][key] = targetResult.GoCbResult().(*gocbcore.GetMetaResult)
					continue
				}
				if !isKeyNotFoundError(sourceResult.Error()) && isKeyNotFoundError(targetResult.Error()) {
					if _, exists := missingFromTarget[tgtColId]; !exists {
						missingFromTarget[tgtColId] = make(map[string]*gocbcore.GetMetaResult)
					}
					missingFromTarget[tgtColId][key] = sourceResult.GoCbResult().(*gocbcore.GetMetaResult)
					continue
				}
				if !areGetMetaResultsTheSame(sourceResult.GoCbResult().(*gocbcore.GetMetaResult), targetResult.GoCbResult().(*gocbcore.GetMetaResult)) {
					if isDeleted(sourceResult.GoCbResult().(*gocbcore.GetMetaResult)) {
						if _, exists := deletedFromSource[srcColId]; !exists {
							deletedFromSource[srcColId] = make(map[string][]*gocbcore.GetMetaResult)
						}
						deletedFromSource[srcColId][key] = append(deletedFromSource[srcColId][key], []*gocbcore.GetMetaResult{sourceResult.GoCbResult().(*gocbcore.GetMetaResult), targetResult.GoCbResult().(*gocbcore.GetMetaResult)}...)
						continue
					}
					if isDeleted(targetResult.GoCbResult().(*gocbcore.GetMetaResult)) {
						if _, exists := deletedFromTarget[tgtColId]; !exists {
							deletedFromTarget[tgtColId] = make(map[string][]*gocbcore.GetMetaResult)
						}
						deletedFromTarget[tgtColId][key] = append(deletedFromTarget[tgtColId][key], []*gocbcore.GetMetaResult{sourceResult.GoCbResult().(*gocbcore.GetMetaResult), targetResult.GoCbResult().(*gocbcore.GetMetaResult)}...)
						continue
					}
					if _, exists := srcDiff[srcColId]; !exists {
						srcDiff[srcColId] = make(map[string][]*gocbcore.GetMetaResult)
					}
					srcDiff[srcColId][key] = append(srcDiff[srcColId][key], []*gocbcore.GetMetaResult{sourceResult.GoCbResult().(*gocbcore.GetMetaResult), targetResult.GoCbResult().(*gocbcore.GetMetaResult)}...)
					if _, exists := tgtDiff[tgtColId]; !exists {
						tgtDiff[tgtColId] = make(map[string][]*gocbcore.GetMetaResult)
					}
					tgtDiff[tgtColId][key] = append(tgtDiff[tgtColId][key], []*gocbcore.GetMetaResult{targetResult.GoCbResult().(*gocbcore.GetMetaResult), sourceResult.GoCbResult().(*gocbcore.GetMetaResult)}...)
				}
			}
		}
	}

	// Need to do a double-take from target's point of view - check to see if certain things are missing from source
	for tgtColId, targetResultMap := range dw.targetResults {
		for key, targetResultIfc := range targetResultMap {
			targetResult := targetResultIfc.(*GetMetaResult)
			if targetResult.Key() == "" {
				continue
			}

			srcColIds := dw.reverseColIds[tgtColId]
			var foundSourceColId bool
			var keyExists bool
			for _, srcColId := range srcColIds {
				_, exists := dw.sourceResults[srcColId]
				if exists {
					foundSourceColId = true
					_, keyExists = dw.sourceResults[srcColId][key]
					break
				}
			}
			if !foundSourceColId || !keyExists {
				// This means that the source colId doesn't exist for this target entry
				if _, exists := missingFromTarget[tgtColId]; !exists {
					missingFromTarget[tgtColId] = make(map[string]*gocbcore.GetMetaResult)
				}
				missingFromTarget[tgtColId][key] = targetResult.GoCbResult().(*gocbcore.GetMetaResult)
			}
		}
	}

	dw.differ.addMetaDiff(missingFromSource, missingFromTarget, deletedFromSource, deletedFromTarget, srcDiff, tgtDiff)
}

type batch struct {
	dw                *DifferWorker
	fetchList         MutationDiffFetchList
	waitGroup         sync.WaitGroup
	sourceResultCount uint32
	targetResultCount uint32
	sourceResults     map[uint32]map[string]Result
	targetResults     map[uint32]map[string]Result
	resultsLock       sync.RWMutex
}

func NewBatch(dw *DifferWorker, startIndex, endIndex int) *batch {
	b := &batch{
		dw:            dw,
		fetchList:     dw.fetchList[startIndex:endIndex],
		sourceResults: make(map[uint32]map[string]Result),
		targetResults: make(map[uint32]map[string]Result),
	}

	// initialize all entries in results map
	// update to *GetResult in map will not be treated as concurrent update to map itself
	for _, fetchItem := range b.fetchList {
		if _, exists := b.sourceResults[fetchItem.SrcColId]; !exists {
			b.sourceResults[fetchItem.SrcColId] = make(map[string]Result)
		}
		if dw.differ.compareBody {
			b.sourceResults[fetchItem.SrcColId][fetchItem.Key] = &GetResult{}
		} else {
			b.sourceResults[fetchItem.SrcColId][fetchItem.Key] = &GetMetaResult{}
		}
		for _, tgtColId := range fetchItem.TgtColIds {
			if _, exists := b.targetResults[tgtColId]; !exists {
				b.targetResults[tgtColId] = make(map[string]Result)
			}
			if dw.differ.compareBody {
				b.targetResults[tgtColId][fetchItem.Key] = &GetResult{}
			} else {
				b.targetResults[tgtColId][fetchItem.Key] = &GetMetaResult{}
			}
		}
	}

	return b
}

func (b *batch) send() error {
	for _, fetchItem := range b.fetchList {
		b.get(fetchItem.Key, true, b.dw.differ.compareBody, fetchItem.SrcColId)
		for _, tgtId := range fetchItem.TgtColIds {
			b.get(fetchItem.Key, false, b.dw.differ.compareBody, tgtId)
		}
	}

	doneChan := make(chan bool, 1)
	go utils.WaitForWaitGroup(&b.waitGroup, doneChan)

	timer := time.NewTimer(time.Duration(b.dw.differ.timeout) * time.Second)
	defer timer.Stop()
	for {
		select {
		case <-doneChan:
			return nil
		case <-timer.C:
			return fmt.Errorf("mutation differ batch timed out")
		}
	}
}

func (b *batch) get(key string, isSource bool, getBody bool, colId uint32) {
	getCallbackFunc := func(result *gocbcore.GetResult, err error) {
		var resultsMap map[string]Result
		if isSource {
			resultsMap = b.sourceResults[colId]
		} else {
			resultsMap = b.targetResults[colId]
		}
		resultInMap := resultsMap[key]
		resultInMap.Set(key, result, err)
		b.waitGroup.Done()
	}

	getMetaCallbackFunc := func(result *gocbcore.GetMetaResult, err error) {
		var resultsMap map[string]Result
		if isSource {
			resultsMap = b.sourceResults[colId]
		} else {
			resultsMap = b.targetResults[colId]
		}
		resultInMap := resultsMap[key]
		resultInMap.Set(key, result, err)
		b.waitGroup.Done()
	}

	b.waitGroup.Add(1)
	var err error
	if isSource {
		if getBody {
			err = b.dw.sourceBucket.Get(key, getCallbackFunc, colId)
		} else {
			err = b.dw.sourceBucket.GetMeta(key, getMetaCallbackFunc, colId)
		}
		if err != nil {
			b.dw.logger.Errorf("sourceBucketGetErr %v\n", err)
		}
	} else {
		if getBody {
			err = b.dw.targetBucket.Get(key, getCallbackFunc, colId)
		} else {
			err = b.dw.targetBucket.GetMeta(key, getMetaCallbackFunc, colId)
		}
		if err != nil {
			b.dw.logger.Errorf("targetBucketGetErr %v\n", err)
		}
	}
}

func isKeyNotFoundError(err error) bool {
	return err != nil && strings.Contains(err.Error(), gocbcore.ErrDocumentNotFound.Error())
}

func areGetResultsTheSame(result1, result2 *gocbcore.GetResult) bool {
	if !areGetResultsBodyTheSame(result1, result2) {
		return false
	}

	if result1 == nil && result2 != nil || result1 != nil && result2 == nil {
		return false
	} else if result1 == nil && result2 == nil {
		return true
	} else {
		return result1.Cas == result2.Cas && result1.Flags == result2.Flags && result1.Datatype == result2.Datatype
	}
}

func areGetResultsBodyTheSame(result1, result2 *gocbcore.GetResult) bool {
	if result1 == nil {
		return result2 == nil
	}
	if result2 == nil {
		return false
	}

	return reflect.DeepEqual(result1.Value, result2.Value)
}

func areGetMetaResultsTheSame(result1, result2 *gocbcore.GetMetaResult) bool {
	if result1 == nil && result2 == nil {
		return true
	} else if result1 == nil {
		if isDeleted(result2) {
			return true
		} else {
			return false
		}
	} else if result2 == nil {
		if isDeleted(result1) {
			return true
		} else {
			return false
		}
	} else if isDeleted(result1) && isDeleted(result2) {
		return true
	} else {
		// Only compare json part of datatype
		return result1.Cas == result2.Cas && result1.SeqNo == result2.SeqNo && result1.Flags == result2.Flags &&
			result1.Expiry == result2.Expiry && result1.Deleted == result2.Deleted && (result1.Datatype&base.JSONDataType == result2.Datatype&base.JSONDataType)
	}
}
func isDeleted(result *gocbcore.GetMetaResult) bool {
	if result != nil {
		return result.Deleted != 0
	}
	return false
}

type Result interface {
	Key() string
	Error() error
	Clone() Result
	GoCbResult() interface{}
	Set(key string, result interface{}, err error)
}

type GetResult struct {
	key    string
	result *gocbcore.GetResult
	err    error
	Lock   sync.RWMutex
}

func (r *GetResult) Key() string {
	return r.key
}

func (r *GetResult) Error() error {
	return r.err
}

func (r *GetResult) Clone() Result {
	r.Lock.RLock()
	defer r.Lock.RUnlock()

	// shallow copy is good enough to prevent race
	return &GetResult{
		key:    r.key,
		result: r.result,
		err:    r.err,
	}
}

func (r *GetResult) GoCbResult() interface{} {
	return r.result
}

func (r *GetResult) Set(key string, result interface{}, err error) {
	r.Lock.Lock()
	defer r.Lock.Unlock()
	r.key = key
	r.result = result.(*gocbcore.GetResult)
	r.err = err
}

type GetMetaResult struct {
	key    string
	result *gocbcore.GetMetaResult
	err    error
	Lock   sync.RWMutex
}

func (r *GetMetaResult) Key() string {
	return r.key
}

func (r *GetMetaResult) Error() error {
	return r.err
}

func (r *GetMetaResult) Clone() Result {
	r.Lock.RLock()
	defer r.Lock.RUnlock()
	return &GetMetaResult{
		key:    r.key,
		result: r.result,
		err:    r.err,
	}
}

func (r *GetMetaResult) GoCbResult() interface{} {
	return r.result
}

func (r *GetMetaResult) Set(key string, result interface{}, err error) {
	r.Lock.Lock()
	defer r.Lock.Unlock()
	r.key = key
	r.result = result.(*gocbcore.GetMetaResult)
	r.err = err
}

func (d *MutationDiffer) initialize() error {
	var err error
	err = d.openBucket(d.sourceBucketName, d.sourceReference, true)
	if err != nil {
		return err
	}
	err = d.openBucket(d.targetBucketName, d.targetReference, false)
	if err != nil {
		return err
	}
	return nil
}

func (d *MutationDiffer) openBucket(bucketName string, reference *metadata.RemoteClusterReference, source bool) error {
	var capability = d.srcCapability
	if !source {
		capability = d.tgtCapability
	}

	name := "xdcrDifferMutationDiffer_"
	if source {
		name += "src"
	} else {
		name += "dst"
	}

	connStr, err := reference.MyConnectionStr()
	if err != nil {
		return err
	}

	var auth interface{}
	pwAuth := base.PasswordAuth{
		Username: reference.UserName(),
		Password: reference.Password(),
	}

	err = d.initializeKVVBMap(source)
	if err != nil {
		return err
	}

	if reference.HttpAuthMech() == xdcrBase.HttpAuthMechHttps {
		auth = &base.CertificateAuth{
			PasswordAuth:     pwAuth,
			CertificateBytes: reference.Certificate(),
		}
		err = d.initializeKvSSLMap(source)
		if err != nil {
			return err
		}
		err = d.initializeKVVBMap(source)
		if err != nil {
			return err
		}
		// For SSL, the connStr will be secure SSL port to KV directly through CCCP
		var sslPort uint16
		var kvVbMap = d.srcKvVbMap
		var sslPortMap = d.srcKvSSLPortMap
		if !source {
			kvVbMap = d.tgtKvVbMap
			sslPortMap = d.tgtKvSSLPortMap
		}
		for k, _ := range kvVbMap {
			connStr = k
			break
		}
		sslPort, found := sslPortMap[connStr]
		if !found {
			return fmt.Errorf("Cannot find SSL port for %v in map %v", connStr, sslPortMap)
		}
		connStr = xdcrBase.GetHostAddr(xdcrBase.GetHostName(connStr), sslPort)
		base.TagCouchbaseSecurePrefix(&connStr)
	} else {
		auth = &pwAuth
		base.TagHttpPrefix(&connStr)
	}

	agent, err := NewGocbcoreAgent(name, []string{connStr}, bucketName, auth, d.batchSize, capability)

	if source {
		d.sourceBucket = agent
	} else {
		d.targetBucket = agent
	}
	return err
}

func (d *MutationDiffer) initializeKvSSLMap(source bool) error {
	var err error
	var connStr string
	if source {
		connStr, err = d.sourceReference.MyConnectionStr()
	} else {
		connStr, err = d.targetReference.MyConnectionStr()
	}
	if err != nil {
		return err
	}

	if source {
		d.srcKvSSLPortMap, err = d.utils.GetMemcachedSSLPortMap(connStr, d.sourceReference.UserName(),
			d.sourceReference.Password(), d.sourceReference.HttpAuthMech(), d.sourceReference.Certificate(),
			d.sourceReference.SANInCertificate(), d.sourceReference.ClientCertificate(), d.sourceReference.ClientKey(),
			d.sourceBucketName, d.logger, false)
	} else {
		d.tgtKvSSLPortMap, err = d.utils.GetMemcachedSSLPortMap(connStr, d.targetReference.UserName(),
			d.targetReference.Password(), d.targetReference.HttpAuthMech(), d.targetReference.Certificate(),
			d.targetReference.SANInCertificate(), d.targetReference.ClientCertificate(), d.targetReference.ClientKey(),
			d.targetBucketName, d.logger, false)
	}
	return nil
}

func (d *MutationDiffer) initializeKVVBMap(source bool) error {
	var err error
	var connStr string
	if source {
		connStr, err = d.sourceReference.MyConnectionStr()
	} else {
		connStr, err = d.targetReference.MyConnectionStr()
	}
	if err != nil {
		return err
	}

	if source {
		_, _, _, _, _, d.srcKvVbMap, err = d.utils.BucketValidationInfo(connStr, d.sourceBucketName, d.sourceReference.UserName(),
			d.sourceReference.Password(), d.sourceReference.HttpAuthMech(), d.sourceReference.Certificate(),
			d.sourceReference.SANInCertificate(), d.sourceReference.ClientCertificate(), d.sourceReference.ClientKey(),
			d.logger)
	} else {
		_, _, _, _, _, d.tgtKvVbMap, err = d.utils.BucketValidationInfo(connStr, d.targetBucketName, d.targetReference.UserName(),
			d.targetReference.Password(), d.targetReference.HttpAuthMech(), d.targetReference.Certificate(),
			d.targetReference.SANInCertificate(), d.targetReference.ClientCertificate(), d.targetReference.ClientKey(),
			d.logger)
	}

	return err
}
