// Copyright (c) 2018 Couchbase, Inc.
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific language governing permissions
// and limitations under the License.

package differ

import (
	"encoding/json"
	"fmt"
	gocbcore "github.com/couchbase/gocbcore/v9"
	xdcrLog "github.com/couchbase/goxdcr/log"
	"github.com/couchbase/goxdcr/metadata"
	"io/ioutil"
	"math"
	"os"
	"reflect"
	"strings"
	"sync"
	"sync/atomic"
	"time"
	"xdcrDiffer/base"
	"xdcrDiffer/utils"
)

type MutationDiffer struct {
	sourceUrl             string
	sourceBucketName      string
	sourceUserName        string
	sourcePassword        string
	targetUrl             string
	targetBucketName      string
	targetUserName        string
	targetPassword        string
	inputDiffKeysFileName string
	srcDiffKeysFileName   string
	tgtDiffKeysFileName   string
	mutationDifferFileDir string
	numberOfWorkers       int
	batchSize             int
	timeout               int

	sourceBucket *GocbcoreAgent
	targetBucket *GocbcoreAgent

	missingFromSource map[uint32]map[string]*gocbcore.GetResult
	missingFromTarget map[uint32]map[string]*gocbcore.GetResult
	srcDiff           map[uint32]map[string][]*gocbcore.GetResult
	tgtDiff           map[uint32]map[string][]*gocbcore.GetResult
	keysWithError     []*MutationDifferFetchEntry
	stateLock         *sync.RWMutex

	numKeysProcessed  uint32
	numKeysWithErrors uint32
	finChan           chan bool

	maxNumOfSendBatchRetry int
	sendBatchRetryInterval time.Duration
	sendBatchMaxBackoff    time.Duration

	logger *xdcrLog.CommonLogger

	sourceDcpAgent *gocbcore.DCPAgent
	targetDcpAgent *gocbcore.DCPAgent

	colIdsMap           map[uint32][]uint32
	reverseTgtColIdsMap map[uint32][]uint32

	srcCapability metadata.Capability
	tgtCapability metadata.Capability
}

func NewMutationDiffer(sourceUrl string, sourceBucketName string, sourceUserName string, sourcePassword string,
	targetUrl string, targetBucketName string, targetUserName string, targetPassword string, fileDifferDir string,
	mutationDifferFileDir string, numberOfWorkers int, batchSize int, timeout int, maxNumOfSendBatchRetry int,
	sendBatchRetryInterval time.Duration, sendBatchMaxBackoff time.Duration, logger *xdcrLog.CommonLogger,
	colIdsMap map[uint32][]uint32, srcCapability metadata.Capability, tgtCapability metadata.Capability) *MutationDiffer {
	// this indicates that mutation differ is expected to read srcDiff fetchList generated by file differ,
	inputDiffKeysFileName := fileDifferDir + base.FileDirDelimiter + base.DiffKeysFileName
	base.TagHttpPrefix(&sourceUrl)
	base.TagHttpPrefix(&targetUrl)
	if len(colIdsMap) == 0 {
		// legacy mode
		colIdsMap = make(map[uint32][]uint32)
		colIdsMap[0] = []uint32{0}
	}
	return &MutationDiffer{
		sourceUrl:              sourceUrl,
		sourceBucketName:       sourceBucketName,
		sourceUserName:         sourceUserName,
		sourcePassword:         sourcePassword,
		targetUrl:              targetUrl,
		targetBucketName:       targetBucketName,
		targetUserName:         targetUserName,
		targetPassword:         targetPassword,
		inputDiffKeysFileName:  inputDiffKeysFileName,
		mutationDifferFileDir:  mutationDifferFileDir,
		numberOfWorkers:        numberOfWorkers,
		batchSize:              batchSize,
		timeout:                timeout,
		missingFromSource:      make(map[uint32]map[string]*gocbcore.GetResult),
		missingFromTarget:      make(map[uint32]map[string]*gocbcore.GetResult),
		srcDiff:                make(map[uint32]map[string][]*gocbcore.GetResult),
		tgtDiff:                make(map[uint32]map[string][]*gocbcore.GetResult),
		keysWithError:          MutationDiffFetchList{},
		stateLock:              &sync.RWMutex{},
		finChan:                make(chan bool),
		maxNumOfSendBatchRetry: maxNumOfSendBatchRetry,
		sendBatchRetryInterval: sendBatchRetryInterval,
		sendBatchMaxBackoff:    sendBatchMaxBackoff,
		logger:                 logger,
		colIdsMap:              colIdsMap,
		reverseTgtColIdsMap:    compileReverseMap(colIdsMap),
		srcDiffKeysFileName:    utils.DiffKeysFileName(true, fileDifferDir, base.DiffKeysFileName),
		tgtDiffKeysFileName:    utils.DiffKeysFileName(false, fileDifferDir, base.DiffKeysFileName),
		srcCapability:          srcCapability,
		tgtCapability:          tgtCapability,
	}
}

func (d *MutationDiffer) Run() error {
	srcDiffKeys, tgtDiffKeys, err := d.loadDiffKeys()
	if err != nil {
		return err
	}

	srcPovFetchList, srcPovFetchIdx := srcDiffKeys.ToFetchEntries(d.colIdsMap)
	tgtPovFetchList, tgtPovFetchIdx := tgtDiffKeys.ToFetchEntries(d.reverseTgtColIdsMap)
	combinedFetchList := dedupFetchLists(srcPovFetchList, srcPovFetchIdx, tgtPovFetchList, tgtPovFetchIdx)

	totalCnt := len(combinedFetchList)

	d.logger.Infof("Mutation srcDiff to work on %v srcPovFetchList with diffs.\n", totalCnt)

	err = d.initialize()
	if err != nil {
		d.logger.Errorf("Error initializing: %v\n", err)
		return err
	}

	go d.reportStatus(totalCnt)

	loadDistribution := utils.BalanceLoad(d.numberOfWorkers, totalCnt)
	waitGroup := &sync.WaitGroup{}
	for i := 0; i < d.numberOfWorkers; i++ {
		lowIndex := loadDistribution[i][0]
		highIndex := loadDistribution[i][1]
		if lowIndex == highIndex {
			// skip workers with 0 load
			continue
		}
		diffWorker := NewDifferWorker(d, d.sourceDcpAgent, d.targetDcpAgent, d.sourceBucket, d.targetBucket, combinedFetchList[lowIndex:highIndex], waitGroup, d.colIdsMap, d.reverseTgtColIdsMap)
		waitGroup.Add(1)
		go diffWorker.run()
	}

	waitGroup.Wait()

	close(d.finChan)

	return d.writeDiff()
}

func dedupFetchLists(srcPovList MutationDiffFetchList, srcIdx MutationDiffFetchListIdx, tgtPovList MutationDiffFetchList, tgtIdx MutationDiffFetchListIdx) MutationDiffFetchList {
	// The goal is to combine and deduplicate into a single source-side view of the fetch list
	var combinedFetchList MutationDiffFetchList
	combinedFetchIdx := make(MutationDiffFetchListIdx)

	// First go through the source side - and make sure that all matching entries are fetched
	for _, srcFetchEntry := range srcPovList {
		combinedEntry := srcFetchEntry.Clone()

		potentialTgtEntries, exists := tgtIdx[combinedEntry.Key]
		if !exists {
			// Make sure this entry at least has non nil src list
			if len(combinedEntry.TgtColIds) == 0 {
				panic("Will be missing target")
			}
		}
		// potentialTgtEntries are based off of the index and so need to ensure that only matching entries are combined
		for _, chkTgtEntry := range potentialTgtEntries {
			var foundMatching bool
			// From target's pov, the TgtColIds are to be source's
			for _, chkSrcId := range chkTgtEntry.TgtColIds {
				if chkSrcId == combinedEntry.SrcColId {
					// This entry matches
					foundMatching = true
					// Make sure that this target's colId exists in the centralized fetch list
					var foundTgt bool
					for _, chkTgtId := range combinedEntry.TgtColIds {
						// chkTgtEntry is from tgt's pov... ensure that tgt's pov, the srcColId is covered
						if chkTgtId == chkTgtEntry.SrcColId {
							foundTgt = true
							break
						}
					}
					if !foundTgt {
						// This target's colId needs to be in the combinedEntry to ensure it is fetched from target KV
						combinedEntry.TgtColIds = append(combinedEntry.TgtColIds, chkTgtEntry.SrcColId)
					}
					break
				}
			}
			if foundMatching {
				break
			}
		}
		combinedFetchList = append(combinedFetchList, combinedEntry)
		combinedFetchIdx.AddEntry(combinedEntry)
	}

	// Now, go through the target side to ensure that if anything the source missed, it is covered
	for _, tgtFetchEntry := range tgtPovList {
		potentialCombinedEntries, exists := combinedFetchIdx[tgtFetchEntry.Key]
		if !exists {
			// This means that this key is not even being fetched from the source at all
			// need to add it to be fetched so that the diff algo can find it
			srcEntries := tgtFetchEntry.Reverse()
			for _, addOneEntry := range srcEntries {
				combinedFetchList = append(combinedFetchList, addOneEntry)
				combinedFetchIdx.AddEntry(addOneEntry)
			}
			continue
		}

		// Key is being fetched from the source but need to check to make sure that the right colId is being fetched
		// since we are working off of the index
		for _, chkSrcColId := range tgtFetchEntry.TgtColIds {
			var foundSourceEntry bool
			for _, potentialEntry := range potentialCombinedEntries {
				if potentialEntry.SrcColId == chkSrcColId {
					foundSourceEntry = true
					break
				}
			}
			if foundSourceEntry {
				break
			} else {
				// From target's pov, the sourceColId -> tgtMap entry is missing
				// This means that for a key that exists in the source's collection, it isn't aware that
				// this target collection also needs to be fetched
				// Add them into the combinedFetchList
				srcEntries := tgtFetchEntry.Reverse()
				for _, addOneEntry := range srcEntries {
					combinedFetchList = append(combinedFetchList, addOneEntry)
					combinedFetchIdx.AddEntry(addOneEntry)
				}
			}
		}
	}
	return combinedFetchList
}

func (d *MutationDiffer) reportStatus(totalKeys int) {
	ticker := time.NewTicker(time.Duration(base.StatsReportInterval) * time.Second)
	defer ticker.Stop()

	var prevNumKeysProcessed uint32 = math.MaxUint32

	for {
		select {
		case <-ticker.C:
			numKeysProcessed := atomic.LoadUint32(&d.numKeysProcessed)
			numKeysWithErrors := atomic.LoadUint32(&d.numKeysWithErrors)
			if prevNumKeysProcessed != math.MaxUint32 {
				d.logger.Infof("%v Mutation differ processed %v fetchList out of %v fetchList. processing rate=%v key/sec\n", time.Now(), numKeysProcessed, totalKeys, (numKeysProcessed-prevNumKeysProcessed)/base.StatsReportInterval)
			} else {
				d.logger.Infof("%v Mutation differ processed %v fetchList out of %v fetchList.\n", time.Now(), numKeysProcessed, totalKeys)

			}
			if numKeysWithErrors > 0 {
				d.logger.Warnf("%v skipped %v fetchList because of errors\n", time.Now(), numKeysWithErrors)
			}
			if numKeysProcessed == uint32(totalKeys) {
				return
			}
			prevNumKeysProcessed = numKeysProcessed
		case <-d.finChan:
			return
		}
	}
}

func (d *MutationDiffer) writeDiff() error {
	err := d.writeKeysWithError()
	if err != nil {
		d.logger.Errorf("Error writing fetchList with errors. err=%v\n", err)
	}

	err = d.writeCollectionMapping()
	if err != nil {
		d.logger.Errorf("Error collection mapping with errors. err=%v\n", err)
	}

	err = d.writeDiffDetails()
	if err != nil {
		d.logger.Errorf("Error writing srcDiff details. err=%v\n", err)
	}
	return err
}

func (d *MutationDiffer) writeDiffDetails() error {
	diffBytes, err := d.getDiffBytes()
	if err != nil {
		return err
	}

	return d.writeDiffBytesToFile(diffBytes)
}

func (d *MutationDiffer) writeCollectionMapping() error {
	fileName := base.MutationDiffColIdMapping
	srcMapFilename := d.mutationDifferFileDir + base.FileDirDelimiter + fileName

	srcMappingBytes, srcErr := json.Marshal(d.colIdsMap)
	if srcErr != nil {
		d.logger.Errorf("Unable to marshal colIdsMap: %v\n", d.colIdsMap)
	} else {
		srcErr = ioutil.WriteFile(srcMapFilename, srcMappingBytes, 0644)
	}

	if srcErr != nil {
		return srcErr
	} else {
		return nil
	}
}

func (d *MutationDiffer) writeKeysWithError() error {
	keysWithErrorBytes, err := json.Marshal(d.keysWithError)
	if err != nil {
		return err
	}

	keysWithErrorFileName := d.mutationDifferFileDir + base.FileDirDelimiter + base.DiffErrorKeysFileName
	keysWithErrorFile, err := os.OpenFile(keysWithErrorFileName, os.O_RDWR|os.O_CREATE, base.FileModeReadWrite)
	if err != nil {
		return err
	}

	defer keysWithErrorFile.Close()

	_, err = keysWithErrorFile.Write(keysWithErrorBytes)
	return err
}

func (d *MutationDiffer) getDiffBytes() ([]byte, error) {
	diff := d.srcDiff
	outputMap := map[string]interface{}{
		"Mismatch":          diff,
		"MissingFromSource": d.missingFromSource,
		"MissingFromTarget": d.missingFromTarget,
	}

	return json.Marshal(outputMap)
}

func (d *MutationDiffer) writeDiffBytesToFile(diffBytes []byte) error {
	fileName := base.MutationDiffFileName
	fullFileName := d.mutationDifferFileDir + base.FileDirDelimiter + fileName

	diffFile, err := os.OpenFile(fullFileName, os.O_RDWR|os.O_CREATE, base.FileModeReadWrite)
	if err != nil {
		return err
	}

	defer diffFile.Close()

	_, err = diffFile.Write(diffBytes)
	return err

}

func (d *MutationDiffer) loadDiffKeys() (DiffKeysMap, DiffKeysMap, error) {
	srcDiffKeysBytes, err := ioutil.ReadFile(d.srcDiffKeysFileName)
	if err != nil {
		return nil, nil, err
	}

	tgtDiffKeyBytes, err := ioutil.ReadFile(d.tgtDiffKeysFileName)
	if err != nil {
		return nil, nil, err
	}

	srcDiffKeys := make(DiffKeysMap)
	tgtDiffKeys := make(DiffKeysMap)

	err = json.Unmarshal(srcDiffKeysBytes, &srcDiffKeys)
	if err != nil {
		return nil, nil, fmt.Errorf("srcUnmarshal %v", err)
	}
	err = json.Unmarshal(tgtDiffKeyBytes, &tgtDiffKeys)
	if err != nil {
		return nil, nil, fmt.Errorf("tgtUnmarshal %v", err)
	}

	return srcDiffKeys, tgtDiffKeys, nil
}

func (d *MutationDiffer) addDiff(missingFromSource, missingFromTarget map[uint32]map[string]*gocbcore.GetResult,
	srcDiff, tgtDiff map[uint32]map[string][]*gocbcore.GetResult,
	srcBodyDiff, tgtBodyDiff map[uint32]map[string][]*gocbcore.GetResult) {
	d.stateLock.Lock()
	defer d.stateLock.Unlock()

	for colId, missingFromSourcePerCol := range missingFromSource {
		if _, exists := d.missingFromSource[colId]; !exists {
			d.missingFromSource[colId] = make(map[string]*gocbcore.GetResult)
		}
		for key, result := range missingFromSourcePerCol {
			d.missingFromSource[colId][key] = result
		}
	}

	for colId, missingFromTargetPerCol := range missingFromTarget {
		if _, exists := d.missingFromTarget[colId]; !exists {
			d.missingFromTarget[colId] = make(map[string]*gocbcore.GetResult)
		}
		for key, result := range missingFromTargetPerCol {
			d.missingFromTarget[colId][key] = result
		}
	}

	for colId, srcDiffPerCol := range srcDiff {
		if _, exists := d.srcDiff[colId]; !exists {
			d.srcDiff[colId] = make(map[string][]*gocbcore.GetResult)
		}
		for key, results := range srcDiffPerCol {
			d.srcDiff[colId][key] = results
		}
	}

	for colId, tgtDiffPerCol := range tgtDiff {
		if _, exists := d.tgtDiff[colId]; !exists {
			d.tgtDiff[colId] = make(map[string][]*gocbcore.GetResult)
		}
		for key, results := range tgtDiffPerCol {
			d.tgtDiff[colId][key] = results
		}
	}
}

func (d *MutationDiffer) addKeysWithError(keysWithError MutationDiffFetchList) {
	d.stateLock.Lock()
	defer d.stateLock.Unlock()
	d.keysWithError = append(d.keysWithError, keysWithError...)
	atomic.AddUint32(&d.numKeysWithErrors, uint32(len(keysWithError)))
}

type DifferWorker struct {
	differ         *MutationDiffer
	fetchList      MutationDiffFetchList
	sourceBucket   *GocbcoreAgent
	targetBucket   *GocbcoreAgent
	sourceDcpAgent *gocbcore.DCPAgent
	targetDcpAgent *gocbcore.DCPAgent
	waitGroup      *sync.WaitGroup
	sourceResults  map[uint32]map[string]*GetResult
	targetResults  map[uint32]map[string]*GetResult
	resultsLock    sync.RWMutex
	logger         *xdcrLog.CommonLogger
	colIds         map[uint32][]uint32
	reverseColIds  map[uint32][]uint32
}

func NewDifferWorker(differ *MutationDiffer, sourceDCPAgent, targetDCPAgent *gocbcore.DCPAgent, sourceBucket, targetBucket *GocbcoreAgent, fetchList MutationDiffFetchList, waitGroup *sync.WaitGroup, colIds, reverseColIds map[uint32][]uint32) *DifferWorker {
	return &DifferWorker{
		differ:         differ,
		sourceBucket:   sourceBucket,
		targetBucket:   targetBucket,
		fetchList:      fetchList,
		waitGroup:      waitGroup,
		sourceResults:  make(map[uint32]map[string]*GetResult),
		targetResults:  make(map[uint32]map[string]*GetResult),
		logger:         differ.logger,
		sourceDcpAgent: sourceDCPAgent,
		targetDcpAgent: targetDCPAgent,
		colIds:         colIds,
		reverseColIds:  reverseColIds,
	}
}

func compileReverseMap(srcToTgts map[uint32][]uint32) map[uint32][]uint32 {
	reverseMap := make(map[uint32][]uint32)

	for srcColId, tgtColIds := range srcToTgts {
		for _, tgtColId := range tgtColIds {
			if _, exists := reverseMap[tgtColId]; !exists {
				reverseMap[tgtColId] = []uint32{}
			}
			var srcExists bool
			for _, chkColId := range reverseMap[tgtColId] {
				if chkColId == srcColId {
					srcExists = true
					break
				}
			}
			if !srcExists {
				reverseMap[tgtColId] = append(reverseMap[tgtColId], srcColId)
			}
		}
	}
	return reverseMap
}

func (dw *DifferWorker) run() {
	defer dw.waitGroup.Done()
	dw.getResults()
	dw.diff()
}

func (dw *DifferWorker) getResults() {
	index := 0
	for {
		if index >= len(dw.fetchList) {
			break
		}

		if index+dw.differ.batchSize < len(dw.fetchList) {
			dw.sendBatchWithRetry(index, index+dw.differ.batchSize)
			index += dw.differ.batchSize
			continue
		}

		dw.sendBatchWithRetry(index, len(dw.fetchList))
		break
	}

}

func (dw *DifferWorker) sendBatchWithRetry(startIndex, endIndex int) {
	sendBatchFunc := func() error {
		batch := NewBatch(dw, startIndex, endIndex)
		err := batch.send()
		if err != nil {
			return err
		}
		dw.mergeResults(batch)
		return nil
	}

	opErr := utils.ExponentialBackoffExecutor("sendBatchWithRetry", dw.differ.sendBatchRetryInterval, dw.differ.maxNumOfSendBatchRetry,
		base.SendBatchBackoffFactor, dw.differ.sendBatchMaxBackoff, sendBatchFunc)
	if opErr != nil {
		dw.logger.Warnf("Skipped check on %v fetchList because of err=%v.\n", endIndex-startIndex, opErr)
		dw.differ.addKeysWithError(dw.fetchList[startIndex:endIndex])
	}
	// fetchList with error are also counted toward keysProcessed
	atomic.AddUint32(&dw.differ.numKeysProcessed, uint32(endIndex-startIndex))
}

// merge results obtained by batch into dw
// no need to lock results in dw since it is never accessed concurrently
// need to lock results in batch since it could still be updated when mergeResults is called
func (dw *DifferWorker) mergeResults(b *batch) {
	for colId, results := range b.sourceResults {
		if _, exists := dw.sourceResults[colId]; !exists {
			dw.sourceResults[colId] = make(map[string]*GetResult)
		}
		for key, result := range results {
			dw.sourceResults[colId][key] = result.Clone()
		}
	}
	for colId, results := range b.targetResults {
		if _, exists := dw.targetResults[colId]; !exists {
			dw.targetResults[colId] = make(map[string]*GetResult)
		}
		for key, result := range results {
			dw.targetResults[colId][key] = result.Clone()
		}
	}
}

func (dw *DifferWorker) diff() {
	missingFromSource := make(map[uint32]map[string]*gocbcore.GetResult)
	missingFromTarget := make(map[uint32]map[string]*gocbcore.GetResult)
	srcDiff := make(map[uint32]map[string][]*gocbcore.GetResult)
	tgtDiff := make(map[uint32]map[string][]*gocbcore.GetResult)
	srcBodyDiff := make(map[uint32]map[string][]*gocbcore.GetResult)
	tgtBodyDiff := make(map[uint32]map[string][]*gocbcore.GetResult)

	for srcColId, sourceResultMap := range dw.sourceResults {
		for key, sourceResult := range sourceResultMap {
			if sourceResult.Key == "" {
				continue
			}

			tgtColIds := dw.colIds[srcColId]

			for _, tgtColId := range tgtColIds {
				targetResult := dw.targetResults[tgtColId][key]
				if targetResult.Key == "" {
					continue
				}
				if isKeyNotFoundError(sourceResult.Error) && !isKeyNotFoundError(targetResult.Error) {
					if _, exists := missingFromSource[srcColId]; !exists {
						missingFromSource[srcColId] = make(map[string]*gocbcore.GetResult)
					}
					missingFromSource[srcColId][key] = targetResult.Result
					continue
				}
				if !isKeyNotFoundError(sourceResult.Error) && isKeyNotFoundError(targetResult.Error) {
					if _, exists := missingFromTarget[tgtColId]; !exists {
						missingFromTarget[tgtColId] = make(map[string]*gocbcore.GetResult)
					}
					missingFromTarget[tgtColId][key] = sourceResult.Result
					continue
				}
				if !areGetResultsTheSame(sourceResult.Result, targetResult.Result) {
					if _, exists := srcDiff[srcColId]; !exists {
						srcDiff[srcColId] = make(map[string][]*gocbcore.GetResult)
					}
					srcDiff[srcColId][key] = append(srcDiff[srcColId][key], []*gocbcore.GetResult{sourceResult.Result, targetResult.Result}...)
					if _, exists := tgtDiff[tgtColId]; !exists {
						tgtDiff[tgtColId] = make(map[string][]*gocbcore.GetResult)
					}
					tgtDiff[tgtColId][key] = append(tgtDiff[tgtColId][key], []*gocbcore.GetResult{targetResult.Result, sourceResult.Result}...)
				}
				if !areGetResultsBodyTheSame(sourceResult.Result, targetResult.Result) {
					if _, exists := srcBodyDiff[srcColId]; !exists {
						srcBodyDiff[srcColId] = make(map[string][]*gocbcore.GetResult)
					}
					srcBodyDiff[srcColId][key] = append(srcBodyDiff[srcColId][key], []*gocbcore.GetResult{sourceResult.Result, targetResult.Result}...)
					if _, exists := tgtBodyDiff[tgtColId]; !exists {
						tgtBodyDiff[tgtColId] = make(map[string][]*gocbcore.GetResult)
					}
					tgtBodyDiff[tgtColId][key] = append(tgtBodyDiff[tgtColId][key], []*gocbcore.GetResult{targetResult.Result, sourceResult.Result}...)
				}
			}
		}
	}

	// Need to do a double-take from target's point of view - check to see if certain things are missing from source
	for tgtColId, targetResultMap := range dw.targetResults {
		for key, targetResult := range targetResultMap {
			if targetResult.Key == "" {
				continue
			}

			srcColIds := dw.reverseColIds[tgtColId]
			var foundSourceColId bool
			var keyExists bool
			for _, srcColId := range srcColIds {
				_, exists := dw.sourceResults[srcColId]
				if exists {
					foundSourceColId = true
					_, keyExists = dw.sourceResults[srcColId][key]
					break
				}
			}
			if !foundSourceColId || !keyExists {
				// This means that the source colId doesn't exist for this target entry
				if _, exists := missingFromTarget[tgtColId]; !exists {
					missingFromTarget[tgtColId] = make(map[string]*gocbcore.GetResult)
				}
				missingFromTarget[tgtColId][key] = targetResult.Result
			}
		}
	}

	dw.differ.addDiff(missingFromSource, missingFromTarget, srcDiff, tgtDiff, srcBodyDiff, tgtBodyDiff)
}

type batch struct {
	dw                *DifferWorker
	fetchList         MutationDiffFetchList
	waitGroup         sync.WaitGroup
	sourceResultCount uint32
	targetResultCount uint32
	sourceResults     map[uint32]map[string]*GetResult
	targetResults     map[uint32]map[string]*GetResult
	resultsLock       sync.RWMutex
}

func NewBatch(dw *DifferWorker, startIndex, endIndex int) *batch {
	b := &batch{
		dw:            dw,
		fetchList:     dw.fetchList[startIndex:endIndex],
		sourceResults: make(map[uint32]map[string]*GetResult),
		targetResults: make(map[uint32]map[string]*GetResult),
	}

	// initialize all entries in results map
	// update to *GetResult in map will not be treated as concurrent update to map itself
	for _, fetchItem := range b.fetchList {
		if _, exists := b.sourceResults[fetchItem.SrcColId]; !exists {
			b.sourceResults[fetchItem.SrcColId] = make(map[string]*GetResult)
		}
		b.sourceResults[fetchItem.SrcColId][fetchItem.Key] = &GetResult{}
		for _, tgtColId := range fetchItem.TgtColIds {
			if _, exists := b.targetResults[tgtColId]; !exists {
				b.targetResults[tgtColId] = make(map[string]*GetResult)
			}
			b.targetResults[tgtColId][fetchItem.Key] = &GetResult{}
		}
	}

	return b
}

func (b *batch) send() error {
	for _, fetchItem := range b.fetchList {
		b.get(fetchItem.Key, true /*isSource*/, fetchItem.SrcColId)
		for _, tgtId := range fetchItem.TgtColIds {
			b.get(fetchItem.Key, false, tgtId)
		}
	}

	doneChan := make(chan bool, 1)
	go utils.WaitForWaitGroup(&b.waitGroup, doneChan)

	timer := time.NewTimer(time.Duration(b.dw.differ.timeout) * time.Second)
	defer timer.Stop()
	for {
		select {
		case <-doneChan:
			return nil
		case <-timer.C:
			return fmt.Errorf("mutation differ batch timed out")
		}
	}
}

func (b *batch) get(key string, isSource bool, colId uint32) {
	getCallbackFunc := func(result *gocbcore.GetResult, err error) {
		var resultsMap map[string]*GetResult
		if isSource {
			resultsMap = b.sourceResults[colId]
		} else {
			resultsMap = b.targetResults[colId]
		}
		resultInMap := resultsMap[key]
		resultInMap.Lock.Lock()
		resultInMap.Key = key
		resultInMap.Result = result
		resultInMap.Error = err
		resultInMap.Lock.Unlock()

		b.waitGroup.Done()
	}

	b.waitGroup.Add(1)
	if isSource {
		err := b.dw.sourceBucket.Get(key, getCallbackFunc, colId)
		if err != nil {
			b.dw.logger.Errorf("sourceBucketGetErr %v\n", err)
		}
	} else {
		err := b.dw.targetBucket.Get(key, getCallbackFunc, colId)
		if err != nil {
			b.dw.logger.Errorf("targetBucketGetErr %v\n", err)
		}
	}
}

func isKeyNotFoundError(err error) bool {
	return err != nil && strings.Contains(err.Error(), gocbcore.ErrDocumentNotFound.Error())
}

func areGetResultsTheSame(result1, result2 *gocbcore.GetResult) bool {
	if !areGetResultsBodyTheSame(result1, result2) {
		return false
	}

	if result1 == nil && result2 != nil || result1 != nil && result2 == nil {
		return false
	} else if result1 == nil && result2 == nil {
		return true
	} else {
		return result1.Cas == result2.Cas && result1.Flags == result2.Flags && result1.Datatype == result2.Datatype
	}
}

func areGetResultsBodyTheSame(result1, result2 *gocbcore.GetResult) bool {
	if result1 == nil {
		return result2 == nil
	}
	if result2 == nil {
		return false
	}

	return reflect.DeepEqual(result1.Value, result2.Value)
}

type GetResult struct {
	Key    string
	Result *gocbcore.GetResult
	Error  error
	Lock   sync.RWMutex
}

func (r *GetResult) Clone() *GetResult {
	r.Lock.RLock()
	defer r.Lock.RUnlock()

	// shallow copy is good enough to prevent race
	return &GetResult{
		Key:    r.Key,
		Result: r.Result,
		Error:  r.Error,
	}
}

func (d *MutationDiffer) initialize() error {
	var err error
	err = d.openBucket(d.sourceUrl, d.sourceBucketName, d.sourceUserName, d.sourcePassword, true)
	if err != nil {
		return err
	}
	err = d.openBucket(d.targetUrl, d.targetBucketName, d.targetUserName, d.targetPassword, false)
	if err != nil {
		return err
	}
	return nil
}

func (d *MutationDiffer) openBucket(url, bucketName, username, password string, source bool) error {
	var capability = d.srcCapability
	if !source {
		capability = d.tgtCapability
	}

	name := "xdcrDifferMutationDiffer_"
	if source {
		name += "src"
	} else {
		name += "dst"
	}

	agent, err := NewGocbcoreAgent(name, []string{url}, bucketName, &base.PasswordAuth{
		Username: username,
		Password: password,
	}, d.batchSize, capability)

	if source {
		d.sourceBucket = agent
	} else {
		d.targetBucket = agent
	}
	return err
}
