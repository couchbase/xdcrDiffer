// Copyright (c) 2018 Couchbase, Inc.
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License. You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied. See the License for the specific language governing permissions
// and limitations under the License.

package differ

import (
	"encoding/json"
	"fmt"
	xdcrLog "github.com/couchbase/goxdcr/log"
	"strings"
	"xdcrDiffer/base"
	"xdcrDiffer/utils"
	gocbcore "github.com/couchbase/gocbcore/v9"
	"io/ioutil"
	"math"
	"os"
	"reflect"
	"sync"
	"sync/atomic"
	"time"
)

type MutationDiffer struct {
	sourceUrl             string
	sourceBucketName      string
	sourceUserName        string
	sourcePassword        string
	targetUrl             string
	targetBucketName      string
	targetUserName        string
	targetPassword        string
	inputDiffKeysFileName string
	mutationDifferFileDir string
	numberOfWorkers       int
	batchSize             int
	timeout               int

	sourceBucket *GocbcoreAgent
	targetBucket *GocbcoreAgent

	missingFromSource map[string]*gocbcore.GetResult
	missingFromTarget map[string]*gocbcore.GetResult
	diff              map[string][]*gocbcore.GetResult
	bodyDiff          map[string][]*gocbcore.GetResult
	keysWithError     []string
	stateLock         *sync.RWMutex

	numKeysProcessed  uint32
	numKeysWithErrors uint32
	finChan           chan bool

	maxNumOfSendBatchRetry int
	sendBatchRetryInterval time.Duration
	sendBatchMaxBackoff    time.Duration

	logger *xdcrLog.CommonLogger

	sourceDcpAgent *gocbcore.DCPAgent
	targetDcpAgent *gocbcore.DCPAgent
}

func NewMutationDiffer(sourceUrl string,
	sourceBucketName string,
	sourceUserName string,
	sourcePassword string,
	targetUrl string,
	targetBucketName string,
	targetUserName string,
	targetPassword string,
	fileDifferDir string,
	mutationDifferFileDir string,
	inputDiffKeysFileDir string,
	numberOfWorkers int,
	batchSize int,
	timeout int,
	maxNumOfSendBatchRetry int,
	sendBatchRetryInterval time.Duration,
	sendBatchMaxBackoff time.Duration,
	logger *xdcrLog.CommonLogger) *MutationDiffer {
	var inputDiffKeysFileName string
	if len(inputDiffKeysFileDir) == 0 {
		// this indicates that mutation differ is expected to read diff keys generated by file differ,
		inputDiffKeysFileName = fileDifferDir + base.FileDirDelimiter + base.DiffKeysFileName
	} else {
		// this indicates that mutation differ is expected to read diff keys generated by mutation differ itself
		inputDiffKeysFileName = inputDiffKeysFileDir + base.FileDirDelimiter + base.MutationDiffKeysFileName
	}
	base.TagHttpPrefix(&sourceUrl)
	base.TagHttpPrefix(&targetUrl)
	return &MutationDiffer{
		sourceUrl:              sourceUrl,
		sourceBucketName:       sourceBucketName,
		sourceUserName:         sourceUserName,
		sourcePassword:         sourcePassword,
		targetUrl:              targetUrl,
		targetBucketName:       targetBucketName,
		targetUserName:         targetUserName,
		targetPassword:         targetPassword,
		inputDiffKeysFileName:  inputDiffKeysFileName,
		mutationDifferFileDir:  mutationDifferFileDir,
		numberOfWorkers:        numberOfWorkers,
		batchSize:              batchSize,
		timeout:                timeout,
		missingFromSource:      make(map[string]*gocbcore.GetResult),
		missingFromTarget:      make(map[string]*gocbcore.GetResult),
		diff:                   make(map[string][]*gocbcore.GetResult),
		bodyDiff:               make(map[string][]*gocbcore.GetResult),
		keysWithError:          make([]string, 0),
		stateLock:              &sync.RWMutex{},
		finChan:                make(chan bool),
		maxNumOfSendBatchRetry: maxNumOfSendBatchRetry,
		sendBatchRetryInterval: sendBatchRetryInterval,
		sendBatchMaxBackoff:    sendBatchMaxBackoff,
		logger:                 logger,
	}
}

func (d *MutationDiffer) Run() error {
	diffKeys, err := d.loadDiffKeys()
	if err != nil {
		return err
	}

	d.logger.Infof("Mutation diff to work on %v keys with diffs.\n", len(diffKeys))

	err = d.initialize()
	if err != nil {
		d.logger.Errorf("Error initializing: %v\n", err)
		return err
	}

	go d.reportStatus(len(diffKeys))

	loadDistribution := utils.BalanceLoad(d.numberOfWorkers, len(diffKeys))
	waitGroup := &sync.WaitGroup{}
	for i := 0; i < d.numberOfWorkers; i++ {
		lowIndex := loadDistribution[i][0]
		highIndex := loadDistribution[i][1]
		if lowIndex == highIndex {
			// skip workers with 0 load
			continue
		}
		diffWorker := NewDifferWorker(d, d.sourceDcpAgent, d.targetDcpAgent, d.sourceBucket, d.targetBucket, diffKeys[lowIndex:highIndex], waitGroup)
		waitGroup.Add(1)
		go diffWorker.run()
	}

	waitGroup.Wait()

	close(d.finChan)

	d.writeDiff()

	return nil
}

func (d *MutationDiffer) reportStatus(totalKeys int) {
	ticker := time.NewTicker(time.Duration(base.StatsReportInterval) * time.Second)
	defer ticker.Stop()

	var prevNumKeysProcessed uint32 = math.MaxUint32

	for {
		select {
		case <-ticker.C:
			numKeysProcessed := atomic.LoadUint32(&d.numKeysProcessed)
			numKeysWithErrors := atomic.LoadUint32(&d.numKeysWithErrors)
			if prevNumKeysProcessed != math.MaxUint32 {
				d.logger.Infof("%v Mutation differ processed %v keys out of %v keys. processing rate=%v key/sec\n", time.Now(), numKeysProcessed, totalKeys, (numKeysProcessed-prevNumKeysProcessed)/base.StatsReportInterval)
			} else {
				d.logger.Infof("%v Mutation differ processed %v keys out of %v keys.\n", time.Now(), numKeysProcessed, totalKeys)

			}
			if numKeysWithErrors > 0 {
				d.logger.Warnf("%v skipped %v keys because of errors\n", time.Now(), numKeysWithErrors)
			}
			if numKeysProcessed == uint32(totalKeys) {
				return
			}
			prevNumKeysProcessed = numKeysProcessed
		case <-d.finChan:
			return
		}
	}
}

func (d *MutationDiffer) writeDiff() error {
	err := d.writeKeysWithDiff()
	if err != nil {
		d.logger.Errorf("Error writing keys with diff. err=%v\n", err)
	}

	err = d.writeKeysWithError()
	if err != nil {
		d.logger.Errorf("Error writing keys with errors. err=%v\n", err)
	}

	err = d.writeDiffDetails()
	if err != nil {
		d.logger.Errorf("Error writing diff details. err=%v\n", err)
	}
	return err
}

func (d *MutationDiffer) writeKeysWithDiff() error {
	err := d.writeKeysWithDiff2(true)
	if err != nil {
		d.logger.Errorf("Error writing mutation body diff keys. err=%v\n", err)
	}

	err = d.writeKeysWithDiff2(false)
	if err != nil {
		d.logger.Errorf("Error writing mutation diff keys. err=%v\n", err)
	}
	return err
}

func (d *MutationDiffer) writeKeysWithDiff2(isBodyDiff bool) error {
	diff := d.diff
	fileName := base.MutationDiffKeysFileName
	if isBodyDiff {
		diff = d.bodyDiff
		fileName = base.MutationBodyDiffKeysFileName
	}

	// aggragate all keys with diffs into a diffKeys array
	numberOfDiffKeys := len(d.missingFromSource) + len(d.missingFromTarget) + len(diff)
	diffKeys := make([]string, numberOfDiffKeys)
	index := 0
	for key, _ := range d.missingFromSource {
		diffKeys[index] = key
		index++
	}
	for key, _ := range d.missingFromTarget {
		diffKeys[index] = key
		index++
	}
	for key, _ := range diff {
		diffKeys[index] = key
		index++
	}

	diffKeysBytes, err := json.Marshal(diffKeys)
	if err != nil {
		return err
	}

	diffKeysFileName := d.mutationDifferFileDir + base.FileDirDelimiter + fileName

	diffKeysFile, err := os.OpenFile(diffKeysFileName, os.O_RDWR|os.O_CREATE, base.FileModeReadWrite)
	if err != nil {
		return err
	}

	defer diffKeysFile.Close()

	_, err = diffKeysFile.Write(diffKeysBytes)
	return err
}

func (d *MutationDiffer) writeDiffDetails() error {
	err := d.writeDiffDetails2(true)
	if err != nil {
		d.logger.Errorf("Error writing mutation body diff details. err=%v\n", err)
	}

	err = d.writeDiffDetails2(false)
	if err != nil {
		d.logger.Errorf("Error writing mutation diff details. err=%v\n", err)
	}

	return err
}

func (d *MutationDiffer) writeDiffDetails2(isBodyDiff bool) error {
	diffBytes, err := d.getDiffBytes(isBodyDiff)
	if err != nil {
		return err
	}

	return d.writeDiffBytesToFile(diffBytes, isBodyDiff)
}

func (d *MutationDiffer) writeKeysWithError() error {
	keysWithErrorBytes, err := json.Marshal(d.keysWithError)
	if err != nil {
		return err
	}

	keysWithErrorFileName := d.mutationDifferFileDir + base.FileDirDelimiter + base.DiffErrorKeysFileName
	keysWithErrorFile, err := os.OpenFile(keysWithErrorFileName, os.O_RDWR|os.O_CREATE, base.FileModeReadWrite)
	if err != nil {
		return err
	}

	defer keysWithErrorFile.Close()

	_, err = keysWithErrorFile.Write(keysWithErrorBytes)
	return err
}

func (d *MutationDiffer) getDiffBytes(isBodyDiff bool) ([]byte, error) {
	diff := d.diff
	if isBodyDiff {
		diff = d.bodyDiff
	}
	outputMap := map[string]interface{}{
		"Mismatch":          diff,
		"MissingFromSource": d.missingFromSource,
		"MissingFromTarget": d.missingFromTarget,
	}

	return json.Marshal(outputMap)
}

func (d *MutationDiffer) writeDiffBytesToFile(diffBytes []byte, isBodyDiff bool) error {
	fileName := base.MutationDiffFileName
	if isBodyDiff {
		fileName = base.MutationBodyDiffFileName
	}
	fullFileName := d.mutationDifferFileDir + base.FileDirDelimiter + fileName

	diffFile, err := os.OpenFile(fullFileName, os.O_RDWR|os.O_CREATE, base.FileModeReadWrite)
	if err != nil {
		return err
	}

	defer diffFile.Close()

	_, err = diffFile.Write(diffBytes)
	return err

}

func (d *MutationDiffer) loadDiffKeys() ([]string, error) {
	diffKeysBytes, err := ioutil.ReadFile(d.inputDiffKeysFileName)
	if err != nil {
		return nil, err
	}

	diffKeys := make([]string, 0)
	err = json.Unmarshal(diffKeysBytes, &diffKeys)
	if err != nil {
		return nil, err
	}
	return diffKeys, nil
}

func (d *MutationDiffer) addDiff(missingFromSource map[string]*gocbcore.GetResult,
	missingFromTarget map[string]*gocbcore.GetResult,
	diff map[string][]*gocbcore.GetResult, bodyDiff map[string][]*gocbcore.GetResult) {
	d.stateLock.Lock()
	defer d.stateLock.Unlock()

	for key, result := range missingFromSource {
		d.missingFromSource[key] = result
	}
	for key, result := range missingFromTarget {
		d.missingFromTarget[key] = result
	}
	for key, results := range diff {
		d.diff[key] = results
	}
	for key, results := range bodyDiff {
		d.bodyDiff[key] = results
	}
}

func (d *MutationDiffer) addKeysWithError(keysWithError []string) {
	d.stateLock.Lock()
	defer d.stateLock.Unlock()
	d.keysWithError = append(d.keysWithError, keysWithError...)
	atomic.AddUint32(&d.numKeysWithErrors, uint32(len(keysWithError)))
}

type DifferWorker struct {
	differ *MutationDiffer
	// keys to do diff on
	keys           []string
	sourceBucket   *GocbcoreAgent
	targetBucket   *GocbcoreAgent
	sourceDcpAgent *gocbcore.DCPAgent
	targetDcpAgent *gocbcore.DCPAgent
	waitGroup      *sync.WaitGroup
	sourceResults  map[string]*GetResult
	targetResults  map[string]*GetResult
	resultsLock    sync.RWMutex
	logger         *xdcrLog.CommonLogger
}

func NewDifferWorker(differ *MutationDiffer, sourceDCPAgent, targetDCPAgent *gocbcore.DCPAgent, sourceBucket, targetBucket *GocbcoreAgent, keys []string, waitGroup *sync.WaitGroup) *DifferWorker {
	return &DifferWorker{
		differ:         differ,
		sourceBucket:   sourceBucket,
		targetBucket:   targetBucket,
		keys:           keys,
		waitGroup:      waitGroup,
		sourceResults:  make(map[string]*GetResult),
		targetResults:  make(map[string]*GetResult),
		logger:         differ.logger,
		sourceDcpAgent: sourceDCPAgent,
		targetDcpAgent: targetDCPAgent,
	}
}

func (dw *DifferWorker) run() {
	defer dw.waitGroup.Done()
	dw.getResults()
	dw.diff()
}

func (dw *DifferWorker) getResults() {
	index := 0
	for {
		if index >= len(dw.keys) {
			break
		}

		if index+dw.differ.batchSize < len(dw.keys) {
			dw.sendBatchWithRetry(index, index+dw.differ.batchSize)
			index += dw.differ.batchSize
			continue
		}

		dw.sendBatchWithRetry(index, len(dw.keys))
		break
	}

}

func (dw *DifferWorker) sendBatchWithRetry(startIndex, endIndex int) {
	sendBatchFunc := func() error {
		batch := NewBatch(dw, startIndex, endIndex)
		err := batch.send()
		if err != nil {
			return err
		}
		dw.mergeResults(batch)
		return nil
	}

	opErr := utils.ExponentialBackoffExecutor("sendBatchWithRetry", dw.differ.sendBatchRetryInterval, dw.differ.maxNumOfSendBatchRetry,
		base.SendBatchBackoffFactor, dw.differ.sendBatchMaxBackoff, sendBatchFunc)
	if opErr != nil {
		dw.logger.Warnf("Skipped check on %v keys because of err=%v.\n", endIndex-startIndex, opErr)
		dw.differ.addKeysWithError(dw.keys[startIndex:endIndex])
	}
	// keys with error are also counted toward keysProcessed
	atomic.AddUint32(&dw.differ.numKeysProcessed, uint32(endIndex-startIndex))
}

// merge results obtained by batch into dw
// no need to lock results in dw since it is never accessed concurrently
// need to lock results in batch since it could still be updated when mergeResults is called
func (dw *DifferWorker) mergeResults(b *batch) {
	for key, result := range b.sourceResults {
		dw.sourceResults[key] = result.Clone()
	}
	for key, result := range b.targetResults {
		dw.targetResults[key] = result.Clone()
	}

}

func (dw *DifferWorker) diff() {
	missingFromSource := make(map[string]*gocbcore.GetResult)
	missingFromTarget := make(map[string]*gocbcore.GetResult)
	diff := make(map[string][]*gocbcore.GetResult)
	bodyDiff := make(map[string][]*gocbcore.GetResult)

	for key, sourceResult := range dw.sourceResults {
		if sourceResult.Key == "" {
			//fmt.Printf("Skipping diff on %v since we did not get results from source\n", key)
			continue
		}

		targetResult := dw.targetResults[key]
		if targetResult.Key == "" {
			//fmt.Printf("Skipping diff on %v since we did not get results from target\n", key)
			continue
		}
		if isKeyNotFoundError(sourceResult.Error) && !isKeyNotFoundError(targetResult.Error) {
			missingFromSource[key] = targetResult.Result
			continue
		}
		if !isKeyNotFoundError(sourceResult.Error) && isKeyNotFoundError(targetResult.Error) {
			missingFromTarget[key] = sourceResult.Result
			continue
		}
		if !areGetResultsTheSame(sourceResult.Result, targetResult.Result) {
			diff[key] = []*gocbcore.GetResult{sourceResult.Result, targetResult.Result}
		}
		if !areGetResultsBodyTheSame(sourceResult.Result, targetResult.Result) {
			bodyDiff[key] = []*gocbcore.GetResult{sourceResult.Result, targetResult.Result}
		}
	}

	dw.differ.addDiff(missingFromSource, missingFromTarget, diff, bodyDiff)
}

type batch struct {
	dw                *DifferWorker
	keys              []string
	waitGroup         sync.WaitGroup
	sourceResultCount uint32
	targetResultCount uint32
	sourceResults     map[string]*GetResult
	targetResults     map[string]*GetResult
	resultsLock       sync.RWMutex
}

func NewBatch(dw *DifferWorker, startIndex, endIndex int) *batch {
	b := &batch{
		dw:            dw,
		keys:          dw.keys[startIndex:endIndex],
		sourceResults: make(map[string]*GetResult),
		targetResults: make(map[string]*GetResult),
	}

	// initialize all entries in results map
	// update to *GetResult in map will not be treated as concurrent update to map itself
	for _, key := range b.keys {
		b.sourceResults[key] = &GetResult{}
		b.targetResults[key] = &GetResult{}
	}

	return b
}

func (b *batch) send() error {
	b.waitGroup.Add(2)
	for _, key := range b.keys {
		b.get(key, true /*isSource*/)
		b.get(key, false /*isSource*/)
	}

	doneChan := make(chan bool, 1)
	go utils.WaitForWaitGroup(&b.waitGroup, doneChan)

	timer := time.NewTimer(time.Duration(b.dw.differ.timeout) * time.Second)
	defer timer.Stop()
	for {
		select {
		case <-doneChan:
			return nil
		case <-timer.C:
			return fmt.Errorf("mutation differ batch timed out")
		}
	}

	return nil
}

func (b *batch) get(key string, isSource bool) {
	getCallbackFunc := func(result *gocbcore.GetResult, err error) {
		var resultsMap map[string]*GetResult
		var newCount uint32
		if isSource {
			resultsMap = b.sourceResults
			newCount = atomic.AddUint32(&b.sourceResultCount, 1)
		} else {
			resultsMap = b.targetResults
			newCount = atomic.AddUint32(&b.targetResultCount, 1)
		}
		resultInMap := resultsMap[key]
		resultInMap.Lock.Lock()
		resultInMap.Key = string(key)
		resultInMap.Result = result
		resultInMap.Error = err
		resultInMap.Lock.Unlock()

		if newCount == uint32(len(b.keys)) {
			b.waitGroup.Done()
		}
	}

	if isSource {
		// TODO - collection support
		err := b.dw.sourceBucket.Get(key, "_default", "_default", getCallbackFunc)
		if err != nil {
			b.dw.logger.Errorf("sourceBucketGetErr %v\n", err)
		}
	} else {
		// TODO - collection support
		err := b.dw.targetBucket.Get(key, "_default", "_default", getCallbackFunc)
		if err != nil {
			b.dw.logger.Errorf("targetBucketGetErr %v\n", err)
		}
	}
}

func isKeyNotFoundError(err error) bool {
	return err != nil && strings.Contains(err.Error(),  gocbcore.ErrDocumentNotFound.Error())
}

func areGetResultsTheSame(result1, result2 *gocbcore.GetResult) bool {
	if !areGetResultsBodyTheSame(result1, result2) {
		return false
	}

	if result1 == nil && result2 != nil || result1 != nil && result2 == nil {
		return false
	} else if result1 == nil && result2 == nil {
		return true
	} else {
		return result1.Cas == result2.Cas && result1.Flags == result2.Flags && result1.Datatype == result2.Datatype
	}
}

func areGetResultsBodyTheSame(result1, result2 *gocbcore.GetResult) bool {
	if result1 == nil {
		return result2 == nil
	}
	if result2 == nil {
		return false
	}

	return reflect.DeepEqual(result1.Value, result2.Value)
}

type GetResult struct {
	Key    string
	Result *gocbcore.GetResult
	Error  error
	Lock   sync.RWMutex
}

func (r *GetResult) Clone() *GetResult {
	r.Lock.RLock()
	defer r.Lock.RUnlock()

	// shallow copy is good enough to prevent race
	return &GetResult{
		Key:    r.Key,
		Result: r.Result,
		Error:  r.Error,
	}
}

func (d *MutationDiffer) initialize() error {
	var err error
	err = d.openBucket(d.sourceUrl, d.sourceBucketName, d.sourceUserName, d.sourcePassword, true)
	if err != nil {
		return err
	}
	err = d.openBucket(d.targetUrl, d.targetBucketName, d.targetUserName, d.targetPassword, false)
	if err != nil {
		return err
	}
	return nil
}

func (d *MutationDiffer) openBucket(url, bucketName, username, password string, source bool) error {
	// TODO - use RBAC?
	//if !strings.HasPrefix(url, "http") {
	//	url = fmt.Sprintf("http://%v", url)
	//}
	//rbacSupported, bucketPassword, err := utils.GetRBACSupportedAndBucketPassword(url, bucketName, username, password)
	//if err != nil {
	//	d.logger.Errorf("Error occurred when getting RBAC supported bucket password %v\n", err)
	//	return nil, err
	//}
	//d.logger.Infof("%v rbacSupported=%v\n", url, rbacSupported)

	name := "xdcrDifferMutationDiffer_"
	if source {
		name += "src"
	} else {
		name += "dst"
	}

	agent, err := NewGocbcoreAgent(name, []string{url}, bucketName, &base.PasswordAuth{
		Username: username,
		Password: password,
	})

	if source {
		d.sourceBucket = agent
		d.logger.Errorf("sourceAgent %v err %v\n", agent, err)
	} else {
		d.targetBucket = agent
		d.logger.Errorf("targetAgent %v err %v\n", agent, err)
	}
	return err
}
